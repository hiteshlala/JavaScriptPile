{"name":"Javascript Pile","tagline":"Bunch of projects I worked on","body":"#JavaScript Pile\r\nA collection of functions written for practice. I tried to separate some functions which stand alone as a project and could potentially be useful at a later time to make.\r\n\r\n###[permutations.js](https://github.com/hiteshlala/JavaScriptPile/blob/master/permutations.js)\r\na basic function to permute using recursion. Did this some time ago and definitely needs revisiting\r\n\r\n###phoneNumToText.js\r\nwas trying to get a list of text strings from a phone number. Works but you het a huge list so beware\r\n\r\n###recursiveTrees.js\r\n    ` \r\n//Functions and Fractals - Recursive Trees\r\nvar recurseTree = function(iterations, height) {\r\n  height = height || 16;\r\n\r\n  // these are the characters for image\r\n  //  o - open area, l - line part\r\n  var o = \" \";\r\n  var l = \"*\";\r\n\r\n  // generates an upside down Y of \r\n  // height = 2 * height \r\n  // width = 2 * height + 1\r\n  var drawY = function(height){\r\n    var image = [];\r\n    \r\n    // constructin the I part\r\n    for(var i = 0; i < height; i++) {\r\n      image.push([]);\r\n      for(var j = 0; j < height; j++) {\r\n        image[i].push(o);\r\n      }\r\n      image[i].push(l);\r\n      for(var j = 0; j < height; j++) {\r\n        image[i].push(o);\r\n      }\r\n    }\r\n\r\n    // constructing the v part\r\n    for(var i = height; i < height * 2; i++) {\r\n      image.push([]);\r\n      for(var j = 0; j < height * 2 - 1; j++) {\r\n        if(j === height * 2 - i - 1 ) image[i].push(l);\r\n        if(j === i ) image[i].push(l);\r\n        image[i].push(o);\r\n      }\r\n    }\r\n    // this line to catch a wierd edge effect\r\n    image[height * 2 - 1].push(l);\r\n\r\n    return image;\r\n  };\r\n\r\n  var drawSubY =  function(height, iter) {\r\n\r\n    if(iter === 0) {\r\n      // base case\r\n      return drawY(height);\r\n    } else {\r\n      // recursive case\r\n      var smallY = drawSubY(height/2, iter - 1);\r\n      var bigY = drawY(height);\r\n    }\r\n\r\n    var image = [];\r\n    var newHeight = smallY.length + bigY.length;\r\n    var newWidth = bigY[0].length + Math.floor(smallY[0].length / 2) * 2;\r\n\r\n    var bigYi = 0;\r\n    var bigYj = 0;\r\n    \r\n    var smallYi = 0;\r\n    var samllYj1 = 0;\r\n    var smallYj2 = 0;\r\n\r\n    // are edge indices for large and small Y's\r\n    var edge1 = Math.floor(smallY[0].length / 2);\r\n    var edge2 = newWidth - edge1;\r\n    var edge3 = smallY[0].length;\r\n    var edge4 = newWidth - smallY[0].length;\r\n\r\n    \r\n    for(var i = 0; i < newHeight; i++) {\r\n      image.push([]);\r\n      bigYj = 0;\r\n      smallYj2 = 0;\r\n      smallYj1 =0;\r\n      for(var j = 0; j < newWidth; j++) {\r\n\r\n        // add large Y\r\n        if(i < height * 2) {\r\n\r\n          if( j < edge1 || j >= edge2) {            \r\n            image[i].push(o);\r\n         \r\n          } else {\r\n            image[i].push(bigY[bigYi][bigYj]);\r\n            bigYj++;\r\n          }\r\n\r\n        // add two little Y's\r\n        } else {\r\n          if(j >= edge4 ) { \r\n            image[i].push(smallY[smallYi][smallYj1]);\r\n            smallYj1++;\r\n\r\n          } else if ( j < edge3 ) {\r\n            image[i].push(smallY[smallYi][smallYj2]);\r\n            smallYj2++;\r\n\r\n          } else {\r\n            image[i].push(o);\r\n          }\r\n        }\r\n      } // for j\r\n\r\n      bigYi++;\r\n      if(i >= height * 2 ) smallYi++;\r\n    } // for i\r\n\r\n    return image;\r\n  };\r\n\r\n  var image = drawSubY(height, iterations);\r\n\r\n  // convert image data from an array to a string\r\n  var assembleImage = function(image) {\r\n    // first invert image data\r\n    image.reverse();\r\n    // join line arrays\r\n    image = image.map(function(item) {\r\n      return item.join(\"\");\r\n    });\r\n    // join lines and return\r\n    return image.join(\"\\n\");\r\n  };\r\n\r\n  return assembleImage( image );\r\n};\r\n`\r\nrecursive function to create a branching tree, can adjust the number of iterations and length of the arms on initial tree\r\n\r\n###sierpinski.js\r\nrecursively generate the Sierpinski triangles. Can adjust the number of iterations.\r\n\r\n###convexHull.js\r\ncalculates the smallest boundary of a group of points in a plane. I implemented Grahams solution orignally published in the 1970's but I found on Wikipedia\r\n\r\n###towersOfHanoi.js\r\nrecursively solves the Towers of Hanoi porblem. Have a funcion that returns a table of moves and a function that prints the moves directly on the screen.\r\n\r\n###flattenObject.js\r\na function that takes a hierarchical map of properties and converts it to a single, flattened map, with the different levels separated by a forward slash ('/').\r\n\r\n###romanNumeral.js\r\nRoman Numeral Converter two functions to convert a given number into a roman numeral. One is iterative the other recursive. Iterative makes more intuitive sense to me.\r\n\r\n###deepEquals.js\r\na function that, given two objects, returns whether or not the two are deeply equivalent--meaning the structure of the two objects is the same, and so is the structure of each of their corresponding descendants.\r\n\r\n###anagrams.js\r\na function that given a string returns all anagrams. Basically all permutaions of the string are retruned in an array.\r\n\r\n###binarySearch.js\r\ngiven an ordered list and an item return the index of the item in that list. Do this recursively.\r\n\r\n###isPrime.js\r\na function that determines if a number is prime. 1 is treated as not prime.\r\n\r\n###smallestCommonMultiple.js\r\nFind the smallest common multiple of the provided parameters that can be evenly divided by both, as well as by all sequential numbers in the range between these parameters. The range will be an array of two numbers that will not necessarily be in numerical order.\r\n\r\n###tagCount.js\r\na function that recursively checks all tags of the document and counts the number of times a given tag appears. The tag and DOM to be checked are inputs.\r\n\r\n###recursiveMultiply.js\r\na recursive function to multiply two positive integers without using the * operator. You can use addition, subtraction, and bit shifting, but you should minimize the number of those operations.\r\n\r\n###makeHtmlPage.sh\r\na shell script to create an html page with a script tag for testing .js files.\r\n\r\n###fibonacci.js\r\nthree functions to calculate fibonacci numbers. One iterative and two recursive (one of the recursive ones has caching). fibonacci sequence starts: 1, 1, 2, 3, 5,.... so 0th element is 1, 1st element is 1, 2nd is 2, etc found using formula f(n) = f(n-1) + f(n-2).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}